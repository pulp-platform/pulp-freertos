#!/usr/bin/env tclsh
# SPDX-License-Identifier: Apache-2.0
# Author: Robert Balas (balasr@iis.ee.ethz.ch)
# Various utilities for interacting with a simulation of pulp/pulpissimo

# the interesting functions for a user are:
# pulp_dump_mem_l2 path - generate a full memory dump as seen from the processor
# pulp_dump_mem_l2_multiple - dumps all l2 related memory contents to multiple
# files
# pulp_flatten_mem_dump - generate a flat memory dump (processor view) of the
#    memory dump for pulp/pulpissimo from an existing dump generated by
#    dump_mem_l2_multiple
# pulp_conv_mem_dump dump_file out_dir - generate a memory image from an
#   executable for pulp based systems
# read_mem_dump name - read a verilog memory dump
# write_mem_dump name - write a verilog memory dump
# cat_mem_dump dump0 dump1 - naively concatenate memory dumps
# split_mem_dump dump split_addr - split a dump into two dumps
# adjust_addr_mem_dump dump offset - change addresses by offset
# merge_mem_dump dump0 dump1 - TODO
# scale_addr_mem_dump dump base_addr scale_n scale_d - scale addresses relative
#   to base_addr by scale_n/scale_d
# fill_mem_dump dump base_addr end_addr width - explicitely fill address range
# deinterleave_mem_dump dump num_banks base_addr - split a memory dump according
#   to the given interleaving pattern
# change_width_mem_dump dump from_width to_width from_endian to_endian -
#  convert between different word widths

# dump the l2 memory of pulp/pulpissmo. This generates a flat view as seen from
# the processor. Note that that the addresses are byte addresses despite the
# native addressing being word addresses. Set scale to 1 if you want the correct
# verilog addresses.
proc pulp_dump_mem_l2 {name {scale 4} {base_addr 0x1c000000}} {
    set tmpdir [exec mktemp -d -p .]
    try {
        pulp_dump_mem_l2_multiple $tmpdir
        pulp_flatten_mem_dump $tmpdir $name $base_addr $scale
    } finally {
        file delete -force -- $tmpdir
    }
}

# dump the l2 memory of pulp/pulpissimo. This needs careful adjustments when
# changing the memory architecture
proc pulp_dump_mem_l2_multiple {path} {
    echo "dumping l2 memory contents to $path"
    set num_banks [examine -radix dec /tb_pulp/i_dut/soc_domain_i/pulp_soc_i/NB_L2_BANKS]
    set num_priv_banks [examine -radix dec /tb_pulp/i_dut/soc_domain_i/pulp_soc_i/NB_L2_BANKS_PRI]

    echo "Number of general memory banks (NB_L2_BANKS): $num_banks"
    echo "Number of private memory banks (NB_L2_BANKS_PRI): $num_priv_banks"

    # private banks
    for {set n 0} {$n < $num_priv_banks} {incr n} { # banks (normally 2)
        mem save -outfile [file join $path/ private_bank_${n}] \
            /tb_pulp/i_dut/soc_domain_i/pulp_soc_i/l2_ram_i/bank_sram_pri${n}_i/MEM \
            -format hex
    }

    # banked l2
    for {set i 0} {$i < $num_banks} {incr i} { # banks (normally 4)
        for {set j 0} {$j < 7} {incr j} { # cuts in bank
            mem save -outfile [file join $path/ bank_${i}_cut_${j}] \
                /tb_pulp/i_dut/soc_domain_i/pulp_soc_i/l2_ram_i/CUTS\[$i\]/bank_i/cut_$j/MEM \
                -format hex
        }
    }

    echo "done"
}

# flattens verilog style memory dumps that are banked according to some pattern.
# This is hardcoded for pulp/pulpissimo
# TODO: we are leaking fds
proc pulp_flatten_mem_dump  {path {name flatten.dump} {base_addr 0x1c000000} {scale 1}} {
    puts "generating a flat memory dump in $name reading from $path"

    set num_banks 4
    set num_priv_banks 2

    puts "Number of general memory banks: $num_banks"
    puts "Number of private memory banks: $num_priv_banks"

    # 0x2000 words in private bank0
    # 0x2000 words in private bank1
    # 0x7000 words in bank0
    # 0x7000 words in bank1
    # 0x7000 words in bank2
    # 0x7000 words in bank3
    # total 0x1c000 words which is 512 kiB
    array set private_bank_dump {}
    array set bank_dump {}

    # load private banks
    for {set n 0} {$n < $num_priv_banks} {incr n} { # banks (normally 2)
        set private_bank_dump($n) [read_mem_dump [file join $path/ private_bank_${n}]]
    }
    # concatenate the private banks
    # offset is 0x4000 since 64KiB in 32-bit words is 0x2000
    set private_bank [cat_mem_dump $private_bank_dump(0) [adjust_addr_mem_dump $private_bank_dump(1) 0x2000]]

    # load banked l2
    for {set i 0} {$i < $num_banks} {incr i} { # banks (normally 4)
        set bank {}
        for {set j 0} {$j < 7} {incr j} { # cuts in bank
            set bank_cut [read_mem_dump [file join $path/ bank_${i}_cut_${j}]]
            # concatenate the cuts, each 4 KiB
            set bank [cat_mem_dump $bank [adjust_addr_mem_dump $bank_cut [expr {$j * 0x1000}]]]
        }
        set bank_dump($i) $bank
    }

    # merge the interleaved banks
    set merged {}

    # TODO: sanity check the banks for size and format etc.
    set lines [llength $bank_dump(0)]

    for {set i 0} {$i < $lines} {incr i} { # lines
        for {set n 0} {$n < $num_banks} {incr n} { # banks
            set elem [lindex [lindex $bank_dump($n) $i] 1]
            lappend merged $elem
        }
    }

    # validation hack for specific memory dumps
    # set count 1
    # foreach ele $merged {
    #     if {[expr 0x$ele] != $count} {
    #         puts "ele=$ele, count=$count"
    #         error "bad count"
    #     }
    #     incr count
    # }

    # concatenate private and interleaved banks and write
    set bank_merged [list_to_mem_dump $merged 0]
    set final_dump [cat_mem_dump $private_bank [adjust_addr_mem_dump $bank_merged 0x4000]]

    # adjust base address
    set final_dump [adjust_addr_mem_dump $final_dump $base_addr $scale]
    write_mem_dump $final_dump $name

    puts "done"
}

# Splits a verilog style memory of an objcopy'd elf file into multiple verilog
# style memory dumps (one per bank) so that it can be quickly preloaded in a
# pulp/pulpissimo simulation with $readmemh. This is the opposite of
# flatten_mem_dump.
proc pulp_conv_mem_dump {dump_file out_dir {base_addr 0x1c000000} {end_addr 0x1c080000}} {
    puts "converting a flat memory dump into multiple bank specific dumps from $dump_file to $out_dir"

    set num_banks 4
    set num_priv_banks 2

    puts "Number of general memory banks: $num_banks"
    puts "Number of private memory banks: $num_priv_banks"

    # load elf, expect word width = 1 byte
    set elf [read_mem_dump $dump_file]

    # fill the holes in the address space with x's, this helps making the
    # de-interleaving process easier
    set elf [fill_mem_dump $elf $base_addr $end_addr 1]

    # convert to 4-byte word addressing
    set elf [change_width_mem_dump $elf 1 4 "little" "little"]
    set elf [scale_addr_mem_dump $elf $base_addr 1 4]

    write_mem_dump $elf [file join $out_dir/ elf.veri]

    set privs [split_mem_dump $elf [expr {$base_addr + 0x2000}]]
    set private_bank0 [adjust_addr_mem_dump [lindex $privs 0] -$base_addr 1]

    # split the rest again
    set privs [split_mem_dump [lindex $privs 1] [expr {$base_addr + 0x4000}]]
    set private_bank1 [adjust_addr_mem_dump [lindex $privs 0] -[expr {$base_addr + 0x2000}] 1]

    set interleaved [lindex $privs 1]

    array set banks {}
    set line_count 0
    set interleaved_base_addr [expr {$base_addr + 0x4000}]

    foreach line $interleaved {
        set addr [expr [lindex $line 0]]
        set value [lindex $line 1]
        set index [expr {$line_count % $num_banks}]

        # rewrite bank addresses
        set increment [expr {$addr - $interleaved_base_addr}]
        set new_addr [expr {$interleaved_base_addr + ($increment / $num_banks)}]

        lappend banks($index) [list [format 0x%llx [expr $new_addr]] $value]

        incr line_count
    }
    # check if we unevenly distributed the entries
    if {[expr {$line_count % $num_banks}] != 0} {
        error "conv_mem_dump: Could not split the interleaved section, not divisible by number of banks"
    }

    array set bank_cuts {}

    # adjust base address of banks
    for {set i 0} {$i < $num_banks} {incr i} {
        set banks($i) [adjust_addr_mem_dump $banks($i) -$interleaved_base_addr 1]
        set slices $banks($i)

        # split banks into slices
        for {set j 0} {$j < 7} {incr j} { # cuts in bank
            # split bank into cuts, each 4 KiB
            set index [expr {$j  + ($i * 7)}]
            set splitted [split_mem_dump $slices [expr {($j + 1) * 0x1000}]]
            set slices [lindex $splitted 1]
            set bank_cuts($index) [lindex $splitted 0]
            set bank_cuts($index) [adjust_addr_mem_dump $bank_cuts($index) -[expr {$j * 0x1000}] 1]
        }
    }

    # write all banks and sliced banks
    write_mem_dump $private_bank0 [file join $out_dir/ private_bank_0]
    write_mem_dump $private_bank1 [file join $out_dir/ private_bank_1]

    foreach {index cut} [array get bank_cuts] {
        set bank_index [expr {$index / 7}]
        set slice_index [expr {$index % 7}]
        write_mem_dump $cut [file join $out_dir/ "bank_${bank_index}_cut_${slice_index}"]
    }

    puts "done"
}

# read a verilog style memory dump into a list of lists, where each internal
# lists starts with the base address and then the values that are placed on the
# subsequent addresses
proc read_mem_dump {name} {
    puts "reading memory dump $name"
    set fp [open $name]
    #  add spaces around newline so that they are treated as a separate token
    #  when splitting
    set normalized [regsub -all "\n" [read $fp] " \n "]
    # split by whitespaces (truncate multiple)
    set tokens [regexp -all -inline {[^[:blank:]]+} $normalized]
    # regex to recognize 4-value
    set fourvalue {^[a-fA-F0-9xzXZ]+$}

    set is_comment 0
    set addr 0
    # it's legal to have no addresses at all appearing the memory dump. For our
    # internal representation we need to forge one (setting it to 0)
    set has_init_addr 0
    # this is the representation of the memory dump it is a list of lists, where
    # each lists first entry is the start address and the subsequent entries are
    # the values
    set dump [list]
    set dump_line [list]

    foreach token $tokens {
        # skip // comments
        if {$token eq "//"} {
            set is_comment 1
        } elseif {$is_comment} {
            if {$token eq "\n"} {
                set is_comment 0
            }
        } elseif {[string match "@*" $token]}  {
            set has_init_addr 1
            # update address counter when seeing @hex_constant
            set addr [string range $token 1 end]
            # -strict prevents bogus empty string too
            if {![string is xdigit -strict $addr]} {
                error "read_mem_dump: address=$token is not a hex constant"
            }
            # check if we already have a valid parsed sequence of values
            if {[llength $dump_line] > 0} {
                lappend dump $dump_line
                set dump_line {}
            }
            # make also sure we put it in as hex constant so that tcl doesn't
            # blow up
            lappend dump_line "0x$addr"
        } elseif {[regexp $fourvalue $token]} {
            # when we didn't see any address indicator, then we start counting
            # assuming addr=0. This is in the sv spec.
            if {!$has_init_addr} {
                set has_init_addr 1
                lappend dump_line 0
            }
            lappend dump_line $token
        } elseif {$token eq "\n" || $token eq " "} {
            # skip empty or newline tokens
        } else {
            error "read_mem_dump: unknown token: \"$token\""
        }
    }

    # add the last line if the file wasn't empty
    if {[llength $dump_line] > 0} {
        lappend dump $dump_line
    }

    close $fp

    # normalize memory dump (i.e. make a list of addr/value pairs). This seems
    # to be the best storage format for conversion operations.
    set normalized_dump [list]
    set normalized_dump_line [list]
    set addr 0
    foreach dump_line $dump {
        # read addr, make sure we convert to decimal i.e. [expr ...]
        set addr [expr [lindex $dump_line 0]]
        foreach token [lrange $dump_line 1 end] {
            set normalized_dump_line [list [format 0x%llx $addr] $token]
            lappend normalized_dump $normalized_dump_line
            incr addr
        }
    }

    return $normalized_dump
}

# write a verilog style memory dump. Opposite of read_mem_dump. Assume that dump
# is a list of addr/value pair (see read_mem_dump).
proc write_mem_dump {dump {name out.dump} {words_per_line 8}} {
    set fp [open $name "w"]

    if {$words_per_line < 1} {
        error "write_mem_dump: unsupported words_per_line value"
    }

    puts $fp "// generated by mem.tcl"
    puts $fp "// depending on the parameters that were used, this might not be a correct"
    puts $fp "// verilog style memory dump, but rather is modified to be human readable"

    set word_count 0

    set addr 0
    set old_addr 0

    foreach dump_line $dump {
        if {[llength $dump_line] == 0} {
            error "write_mem_dump: empty dump_line"
        }
        set addr [expr [lindex $dump_line 0]]
        set value [lindex $dump_line 1]

        if {$word_count == 0} {
            # write new addr counter
            puts -nonewline $fp [format "@%llx" $addr]
            # write first value
            puts -nonewline $fp " $value"

            incr word_count
        } else {
            # verify that address is consecutive
            if {[expr {$old_addr + 1}] != $addr} {
                puts [format "warning: old: 0x%llx new: 0x%llx" $old_addr $addr]
                puts "warning: write_mem_dump: incomplete line, skipping and starting new line"
                set word_count 0

                # write new addr counter
                puts $fp ""
                puts -nonewline $fp [format "@%llx" $addr]
            }

            puts -nonewline $fp " $value"
            if {$word_count == [expr {$words_per_line - 1}]} {
                set word_count 0
                puts $fp ""
            } else {
                incr word_count
            }
        }

        set old_addr $addr
    }

    close $fp
}

# merge memory dumps. Fails when there are overlapping address ranges
proc merge_mem_dump {dump0 dump1} {
    if {[llength $dump0] == 0} {
        error "merge_mem_dump: dump0 is empty"
    }
    if {[llength $dump1] == 0} {
        error "merge_mem_dump: dump1 is empty"
    }
    # # the first entry of the last line is the last line's base address
    # set ll_base_addr [lindex [lindex $dump0 end] 0]
    # set ll_last_addr [expr ll_base_addr + [llength [lindex $dump0 end]] - 1]

    # TODO: interval checking
    error "merge_mem_dump: not implemented yet"
}

# concatenate memory dumps in a naive fashion. Does a sanity check on the
# results for overlapping address ranges (though this is allowed)
proc cat_mem_dump {dump0 dump1} {
    if {[llength $dump0] == 0} {
        # no matter, we just output $dump1
    }
    if {[llength $dump1] == 0} {
        error "cat_mem_dump: dump1 is empty"
    }
    set line_counter 1
    set base_addr 0
    set increment 0
    set end_addr -1

    set cat [concat $dump0 $dump1]

    # TODO: sort by addresses
    foreach line $cat {
        set base_addr [lindex $line 0]
        if {$base_addr <= $end_addr} {
            puts "warning: cat_mem_dump: overlapping address range \
            (base_addr=$base_addr, end_addr=$end_addr) at line $line_counter"
        }
        # remove the base addr
        set increment [expr [llength $line] - 1]
        # add size - 1
        set end_addr [expr {$base_addr + $increment - 1}]

        # misc
        incr line_counter
    }

    return $cat
}

# split memory dump at the given address
proc split_mem_dump {dump split_addr} {
    if {[llength $dump] == 0} {
        error "split_mem_dump: dump is empty"
    }
    set line_counter 1
    set upper {}
    set lower {}

    foreach line $dump {
        set addr [lindex $line 0]
        set value [lindex $line 1]

        if {$addr < $split_addr} {
            lappend upper $line
        } else {
            lappend lower $line
        }
    }
    return [list $upper $lower]
}

# adjust base address of memory dump by offset
# Can also scale addresses of memory dump to make them more human readable (for
# example going from word addressing to byte addressing). Note that such a
# change breaks verilogs $readmemh
proc adjust_addr_mem_dump {dump offset {scale 1}} {
    if {[llength $dump] == 0} {
        error "adjust_addr_mem_dump: dump is empty"
    }
    if {![string is integer $offset]} {
        error "adjust_addr_mem_dump: offset is not an integer"
    }
    # if {!([string is integer $scale] && [$scale > 0])} {
    #     error "adjust_addr_mem_dump: scale is not a valid integer"
    # }

    # due to version constraints we refuse lmap and loop like a plebeian
    for {set i 0} {$i < [llength $dump]} {incr i} {
        set line [lindex $dump $i]
        set base_addr [lindex $line 0]
        # update base addr, make sure we store as hex
        lset line 0 [format 0x%llx [expr {$base_addr * $scale + $offset}]]
        lset dump $i $line
    }
    return $dump
}

# Scale memory addresses by scale with respect to base_addr i.e. addresses
# are scaled as follows: (addr - base_addr) * scale + base_address
proc scale_addr_mem_dump {dump base_addr scale_n scale_d} {
    if {[llength $dump] == 0} {
        error "scale_addr_mem_dump: dump is empty"
    }

    # due to version constraints we refuse lmap and loop like a plebeian
    for {set i 0} {$i < [llength $dump]} {incr i} {
        set line [lindex $dump $i]
        set addr [lindex $line 0]
        # update base addr, make sure we store as hex
        lset line 0 [format 0x%llx \
                         [expr {((($addr - $base_addr) / $scale_d) * $scale_n) + $base_addr}]]

        lset dump $i $line
    }
    return $dump
}

# generate a verilog style memory dump from a list of values, formatted by
# words_per_line and offset by base_addr
proc list_to_mem_dump {lst {base_addr 0}} {
    set mem_dump {}
    set mem_dump_line {}

    for {set i 0} {$i < [llength $lst]} {incr i} {
        lappend mem_dump_line [format 0x%llx [expr {$base_addr + $i}]]
        lappend mem_dump_line [lindex $lst $i]
        lappend mem_dump $mem_dump_line
        set mem_dump_line {}
    }
    return $mem_dump
}

# fill the given address range's holes in the memory dump with X's. Assumes the
# memory dump has only incrementing addresses.
# TODO doesnt work when out of range
proc fill_mem_dump {dump base_addr end_addr {width 4}} {
    set filled_dump {}
    set expected_addr base_addr

    set ele_index 0

    for {set i $base_addr} {$i < $end_addr} {incr i} {
        set ele [lindex $dump $ele_index]
        set ele_addr [expr [lindex $ele 0]]
        set ele_value [lindex $ele 1]

        # puts [format "scan: 0x%llx  ele: 0x%llx" $i $ele_addr]
        if {$i < $ele_addr} {
            lappend filled_dump [list [format 0x%llx $i] [string repeat "xx" $width]]
        } elseif {$i == $ele_addr} {
            lappend filled_dump $ele

            if {$ele_index < [expr [llength $dump] - 1]} {
                incr ele_index
            }
        } else { # $i > $ele_addr
            lappend filled_dump [list [format 0x%llx $i] [string repeat "xx" $width]]
        }
    }

    return $filled_dump
}

# Change word width of memory dump, using the given endianness. Warns if dump is
# not divisible by new word width. The addressing changes from from_width word
# addressing to to_width word addressing, so adjustment using
# adjust_addr_mem_dump might be needed.
proc change_width_mem_dump {dump from_width to_width {from_endian "little"} {to_endian "little"}} {
    if {$from_endian ne "little" && $from_endian ne "big" ||
        $to_endian ne "little" && $to_endian ne "big"} {
        error "change_width_mem_dump: Invalid endian argument"
    }

    if {$from_width > $to_width} {
        error "change_width_mem_dump: Unsupported conversion values. \
              to_width needs to be larger or equal to from_width"
    }

    if {$to_width % $from_width != 0} {
        error "change_width_mem_dump: Unsupported conversion values. \
              to_width needs to be divisible by from_width"
    }

    if {$from_width == $to_width && $from_endian == $to_endian} {
        return $dump
    }

    set new_dump {}
    # in from_width words
    set input_len [llength $dump]
    # in bytes
    set input_bytes_count 0
    set out_addr 0
    set out_value ""

    if {$input_len % $to_width != 0} {
        error "change_width_mem_dump: input dump size is not divisible by $to_width"
    }

    foreach line $dump {
        # strip 0x, so that we can use string concatenation for computing the full value
        set ele $line
        set ele_addr [expr [lindex $ele 0]]
        set ele_value [lindex $ele 1]
        # reorder input if the input/output endianness requires it
        if {$from_endian eq "little" && $to_endian eq "big" ||
            $from_endian eq "big" && $to_endian eq "little"} {
            # reverse string each two character units
            set ele_value [join [lreverse [regsub -all .. $ele_value {& }]] ""]
        }

        # make sure we get the correct output endianness
        if {$to_endian eq "little"} {
            set out_value $ele_value$out_value
        } else {
            set out_value $out_value$ele_value
        }

        if {[expr {$input_bytes_count % $to_width}] == [expr {$to_width - $from_width}]} {
            lappend new_dump [list [format 0x%llx $out_addr] $out_value]
            set out_value ""
        } elseif {[expr {$input_bytes_count % $to_width}] == 0} {
            set out_addr $ele_addr
        }

        incr input_bytes_count $from_width
    }

    return $new_dump
}

# Split a mem dump into banks according to some given interleaving pattern. The
# banks will have their addressing adjusted so that they still start at
# base_addr, but increment without holes caused by the deinterleaving. This
# means that each memory dump can be directly loaded with $readmemh into its
# respective memory bank. Returns an array of memory dumps.
proc deinterleave_mem_dump {dump num_banks base_addr} {
    array set banks {}
    set line_count 0

    foreach line $dump {
        set addr [expr [lindex $line 0]]
        set value [lindex $line 1]
        set index [expr {$line_count % $num_banks}]

        # rewrite bank addresses
        set increment [expr {$addr - $base_addr}]
        set new_addr [expr {$base_addr + ($increment / $num_banks)}]

        lappend banks($index) [list [format 0x%llx [expr $new_addr]] $value]

        incr line_count
    }
    # check if we unevenly distributed the entries
    if {[expr {$line_count % $num_banks}] != 0} {
        error "deinterleave_mem_dump: Could not split the interleaved section, not divisible by number of banks"
    }

    return $banks
}


# if this file is used as script
if {$::argv0 eq [info script]} {
    set mem_file [lindex $::argv 0]
    set out_dir [lindex $::argv 1]

    if {$mem_file eq "" || $out_dir eq ""} {
        puts "mem.tcl is a script to convert verilog style memory dumps"
        puts "usage: mem.tcl mem_file dump_file"
        return 1
    }

    file mkdir $out_dir

    pulp_conv_mem_dump $mem_file $out_dir

    return 0
}
